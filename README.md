
<!--
DO NOT EDIT THIS FILE
It has been generated from the template `README.md.eex` by Extractly (https://github.com/RobertDober/extractly.git)
and any changes you make in this file will most likely be lost
-->

# NestedMap

[![CI](https://github.com/RobertDober/nested_map/actions/workflows/ci.yml/badge.svg)](https://github.com/RobertDober/nested_map/actions/workflows/ci.yml)
[![Coverage Status](https://coveralls.io/repos/github/RobertDober/nested_map/badge.svg?branch=main)](https://coveralls.io/github/RobertDober/nested_map?branch=main)
[![Hex.pm](https://img.shields.io/hexpm/v/nested_map.svg)](https://hex.pm/packages/nested_map)
[![Hex.pm](https://img.shields.io/hexpm/dw/nested_map.svg)](https://hex.pm/packages/nested_map)
[![Hex.pm](https://img.shields.io/hexpm/dt/nested_map.svg)](https://hex.pm/packages/nested_map)


**N.B.**

This README contains the docstrings and doctests from the code by means of [extractly](https://hex.pm/packages/extractly)
and the following code examples are therefore verified with `ExUnit` doctests.

## Dependency

    { :nested_map, ">= 0.1.0" }

  `NestedMap` provides tools to treat nested maps (that came as a surprise),
  notably:

  - accessing nested values with a list of keys
  - flatting a nested map to a list of pairs of list of keys and values
  - nested merging

  ### Accessing

  #### Basic interface

    iex(0)> fetch(%{}, :a) # not found
    :error

    iex(1)> fetch(%{b: 2}, :a, 42) # default
    {:ok, 42}

    iex(2)> fetch(%{a: 2}, :a, 42) # default
    {:ok, 2}

    iex(3)> fetch(%{a: 41}, :a) # found
    {:ok, 41}

    iex(4)> fetch!(%{a: 41}, :a)
    41

    iex(5)> fetch!(%{}, :a, 42)
    42

    iex(6)> try do
    ...(6)>   fetch!(%{}, :a)
    ...(6)> rescue
    ...(6)>   NestedMap.Error -> :caught
    ...(6)> end
    :caught

  #### Applied to nests

    iex(7)> map = %{
    ...(7)>   a: 1,
    ...(7)>   b: %{
    ...(7)>      c: %{
    ...(7)>         a: 100,
    ...(7)>         b: 200
    ...(7)>         },
    ...(7)>      d: 40}}
    ...(7)> {fetch(map, [:b, :c]), fetch(map, [:b, :c, :b]), fetch!(map, [:b, :x], :not_found)}
    {{:ok, %{a: 100, b: 200}}, {:ok, 200}, :not_found}



  ### Flatting


    iex(8)> flatten(%{}) # empty
    []

    iex(9)> flatten(%{a: 1, b: 2}) # flat
    [{[:a], 1}, {[:b], 2}]

    iex(10)> map = %{
    ...(10)>   a: 1,
    ...(10)>   b: %{
    ...(10)>      ["you", "can"] => %{
    ...(10)>          "do" => "that",
    ...(10)>          "if" => %{you: :want}
    ...(10)>      },
    ...(10)>      the_inevitable: 42},
    ...(10)>   c: 2}
    ...(10)> flatten(map) # Be aware that this syntax puts the symbol key
    ...(10)>              # `the_inevitable` before the other keys!
    [{[:a], 1}, {[:b, :the_inevitable], 42}, {[:b, ["you", "can"], "do"], "that"}, {[:b, ["you", "can"], "if", :you], :want}, {[:c], 2}]




## Contributing

Pull Requests are happily accepted.

Please be aware of one _caveat_ when correcting/improving `README.md`.

The `README.md` is generated by `Extractly` as mentioned above and therefore contributers shall not modify it directly, but
`README.md.eex` and the imported docs instead.


## Author

Copyright Â© 2021 Robert Dober robert.dober@gmail.com

# LICENSE

Same as Elixir, which is Apache License v2.0. Please refer to [LICENSE](LICENSE) for details.

SPDX-License-Identifier: Apache-2.0
