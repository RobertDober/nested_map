defmodule NestedMap do
  use NestedMap.Types
  @moduledoc """
    `NestedMap` provides tools to treat nested maps (that came as a surprise),
    notably:

    - accessing nested values with a list of keys
    - flatting a nested map to a list of pairs of list of keys and values
    - nested merging

    ### Accessing
    
    #### Basic interface
    
      iex(0)> get(%{}, :a) # not found
      :error

      iex(1)> get(%{b: 2}, :a, 42) # default
      {:ok, 42}

      iex(2)> get(%{a: 41}, :a) # found
      {:ok, 41}

      iex(3)> get!(%{a: 41}, :a)
      41

      iex(4)> get!(%{}, :a, 42)
      42

    #### Applied to nests


    ### Flatting


      iex(5)> flatten(%{}) # empty
      []

      iex(6)> flatten(%{a: 1, b: 2}) # flat
      [{[:a], 1}, {[:b], 2}]

      iex(7)> map = %{
      ...(7)>   a: 1,
      ...(7)>   b: %{
      ...(7)>      ["you", "can"] => %{
      ...(7)>          "do" => "that",
      ...(7)>          "if" => %{you: :want}
      ...(7)>      },
      ...(7)>      the_inevitable: 42},
      ...(7)>   c: 2}
      ...(7)> flatten(map) # Be aware that this syntax puts the symbol key
      ...(7)>              # `the_inevitable` before the other keys!
      [{[:a], 1}, {[:b, :the_inevitable], 42}, {[:b, ["you", "can"], "do"], "that"}, {[:b, ["you", "can"], "if", :you], :want}, {[:c], 2}]



  """

  @spec flatten(map()) :: flattened_map_t()
  def flatten(map), do: map |> Enum.into([]) |> NestedMap.Flattener.flatten([], [])

  @doc """
  Used by the `xtra` mix task to generate the latest version in the docs, but
  also handy for client applications for quick exploration in `iex`.
  """
  @spec version() :: binary()
  def version() do
    with {:ok, version} = :application.get_key(:nested_map, :vsn),
      do: to_string(version)
  end
end
